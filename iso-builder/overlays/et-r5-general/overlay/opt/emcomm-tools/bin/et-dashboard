#!/usr/bin/env python3
"""
et-dashboard - EmComm-Tools Interactive Dashboard
Author: Sylvain Deguire (VA2OPS)
Date: January 2026
Updated: Added adaptive resolution support
Updated: JS8 button now launches JS8Spotter alongside JS8Call

Replaces Conky with a clickable GTK dashboard
Automatically adjusts to screen resolution changes
"""

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib, Gdk, Pango
import subprocess
import os
import json

class EmCommDashboard(Gtk.Window):
    def __init__(self):
        super().__init__(title="EmComm Dashboard")
        
        # Get screen for adaptive sizing
        self.screen = Gdk.Screen.get_default()
        self.screen_width = self.screen.get_width()
        self.screen_height = self.screen.get_height()
        
        # Calculate adaptive sizes based on resolution
        self.calculate_adaptive_sizes()
        
        # Window setup - desktop widget style (like Conky)
        self.set_decorated(False)
        self.set_skip_taskbar_hint(True)
        self.set_skip_pager_hint(True)
        self.set_keep_below(True)
        self.set_type_hint(Gdk.WindowTypeHint.DOCK)  # Behaves like a dock/panel
        self.stick()
        self.set_accept_focus(False)  # Don't steal focus from other apps
        
        # Prevent accidental closing
        self.connect("delete-event", self.on_delete_event)
        
        # Connect to screen size changes
        self.screen.connect("size-changed", self.on_screen_resize)
        
        # Position top-right (adaptive)
        self.set_default_size(self.panel_width, -1)
        self.move(self.screen_width - self.panel_width - self.margin, self.margin)
        
        # Transparent background
        self.set_app_paintable(True)
        visual = self.screen.get_rgba_visual()
        if visual:
            self.set_visual(visual)
        
        # Apply CSS styling (adaptive)
        self.apply_css()
        
        # Main container
        self.main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.main_box.set_name("dashboard")
        self.add(self.main_box)
        
        # Build UI
        self.build_ui()
        
        # Start update timer
        GLib.timeout_add_seconds(2, self.update_info)
    
    def calculate_adaptive_sizes(self):
        """Calculate sizes based on screen resolution"""
        
        if self.screen_width >= 1920:
            # Full HD and above
            self.panel_width = 350
            self.margin = 10
            self.font_header = 16
            self.font_info = 16
            self.font_callsign = 18
            self.font_utc = 18
            self.font_button = 14
            self.padding = 15
            self.btn_padding = "8px 14px"
            
        elif self.screen_width >= 1680:
            # 1680x1050 (Toughpad)
            self.panel_width = 300
            self.margin = 8
            self.font_header = 14
            self.font_info = 13
            self.font_callsign = 15
            self.font_utc = 15
            self.font_button = 12
            self.padding = 12
            self.btn_padding = "6px 10px"
            
        elif self.screen_width >= 1366:
            # Laptop HD
            self.panel_width = 260
            self.margin = 6
            self.font_header = 12
            self.font_info = 11
            self.font_callsign = 13
            self.font_utc = 13
            self.font_button = 10
            self.padding = 10
            self.btn_padding = "5px 8px"
            
        elif self.screen_width >= 1280:
            # 1280x800 / 1280x720
            self.panel_width = 240
            self.margin = 5
            self.font_header = 11
            self.font_info = 10
            self.font_callsign = 12
            self.font_utc = 12
            self.font_button = 9
            self.padding = 8
            self.btn_padding = "4px 6px"
            
        else:
            # Small screens
            self.panel_width = 200
            self.margin = 5
            self.font_header = 10
            self.font_info = 9
            self.font_callsign = 11
            self.font_utc = 11
            self.font_button = 8
            self.padding = 6
            self.btn_padding = "3px 5px"
        
        print(f"Screen: {self.screen_width}x{self.screen_height} -> Panel: {self.panel_width}px")
    
    def on_screen_resize(self, screen):
        """Handle screen resolution changes"""
        new_width = screen.get_width()
        new_height = screen.get_height()
        
        if new_width != self.screen_width or new_height != self.screen_height:
            print(f"Resolution changed: {new_width}x{new_height}")
            self.screen_width = new_width
            self.screen_height = new_height
            
            # Recalculate sizes
            self.calculate_adaptive_sizes()
            
            # Reposition and resize window
            self.resize(self.panel_width, 1)
            self.move(self.screen_width - self.panel_width - self.margin, self.margin)
            
            # Rebuild UI
            self.rebuild_ui()
    
    def rebuild_ui(self):
        """Rebuild UI with new adaptive sizes"""
        # Remove all children
        for child in self.main_box.get_children():
            self.main_box.remove(child)
        
        # Reapply CSS with new sizes
        self.apply_css()
        
        # Rebuild
        self.build_ui()
        self.show_all()
        
    def apply_css(self):
        css_template = """
        #dashboard {{
            background-color: rgba(30, 30, 30, 0.85);
            border-radius: 8px;
            padding: {padding}px;
        }}
        .section-header {{
            color: #CCCCCC;
            font-weight: bold;
            font-size: {font_header}px;
        }}
        .info-label {{
            color: #888888;
            font-family: monospace;
            font-size: {font_info}px;
        }}
        .callsign {{
            color: #FFA500;
            font-family: monospace;
            font-size: {font_callsign}px;
            font-weight: bold;
        }}
        .status-ok {{
            color: #00CC00;
        }}
        .status-error {{
            color: #CC0000;
        }}
        .utc-time {{
            color: #888888;
            font-family: monospace;
            font-size: {font_utc}px;
        }}
        .config-button {{
            padding: 4px 8px;
            min-height: 0;
            min-width: 0;
            font-size: {font_button}px;
        }}
        .app-button {{
            padding: {btn_padding};
            font-size: {font_button}px;
            font-weight: bold;
        }}
        .separator {{
            background-color: #444444;
            min-height: 1px;
        }}
        """.format(
            padding=self.padding,
            font_header=self.font_header,
            font_info=self.font_info,
            font_callsign=self.font_callsign,
            font_utc=self.font_utc,
            font_button=self.font_button,
            btn_padding=self.btn_padding
        )
        
        style_provider = Gtk.CssProvider()
        style_provider.load_from_data(css_template.encode())
        Gtk.StyleContext.add_provider_for_screen(
            Gdk.Screen.get_default(),
            style_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )
    
    def build_ui(self):
        # === UTC / GPS Section ===
        time_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        time_box.set_margin_bottom(5)
        
        self.utc_label = Gtk.Label()
        self.utc_label.set_name("utc-time")
        self.utc_label.get_style_context().add_class("utc-time")
        time_box.pack_start(self.utc_label, False, False, 0)
        
        self.gps_label = Gtk.Label()
        self.gps_label.get_style_context().add_class("info-label")
        time_box.pack_end(self.gps_label, False, False, 0)
        
        self.main_box.pack_start(time_box, False, False, 0)
        self.main_box.pack_start(self.create_separator(), False, False, 5)
        
        # === INTERFACES Section ===
        iface_header = self.create_section_header("INTERFACES", self.on_radio_clicked)
        self.main_box.pack_start(iface_header, False, False, 0)
        
        self.iface_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        self.iface_box.set_margin_start(5)
        self.iface_box.set_margin_bottom(5)
        
        self.radio_label = self.create_info_row("Radio")
        self.cat_label = self.create_info_row("CAT")
        self.audio_label = self.create_info_row("Audio")
        
        self.iface_box.pack_start(self.radio_label, False, False, 0)
        self.iface_box.pack_start(self.cat_label, False, False, 0)
        self.iface_box.pack_start(self.audio_label, False, False, 0)
        
        self.main_box.pack_start(self.iface_box, False, False, 0)
        self.main_box.pack_start(self.create_separator(), False, False, 5)
        
        # === OPERATOR Section ===
        op_header = self.create_section_header("OPERATOR", self.on_user_clicked)
        self.main_box.pack_start(op_header, False, False, 0)
        
        self.op_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        self.op_box.set_margin_start(5)
        self.op_box.set_margin_bottom(5)
        
        self.callsign_label = Gtk.Label()
        self.callsign_label.get_style_context().add_class("callsign")
        self.op_box.pack_start(self.callsign_label, False, False, 0)
        
        self.grid_label = Gtk.Label()
        self.grid_label.get_style_context().add_class("info-label")
        self.op_box.pack_start(self.grid_label, False, False, 0)
        
        self.main_box.pack_start(self.op_box, False, False, 0)
        self.main_box.pack_start(self.create_separator(), False, False, 5)
        
        # === MODE Section ===
        mode_header = self.create_section_header("MODE", self.on_mode_clicked)
        self.main_box.pack_start(mode_header, False, False, 0)
        
        self.mode_label = Gtk.Label()
        self.mode_label.set_halign(Gtk.Align.START)
        self.mode_label.get_style_context().add_class("info-label")
        self.mode_label.set_margin_start(5)
        self.mode_label.set_margin_bottom(5)
        self.main_box.pack_start(self.mode_label, False, False, 0)
        
        self.main_box.pack_start(self.create_separator(), False, False, 5)
        
        # === Quick Launch Buttons ===
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=4)
        button_box.set_halign(Gtk.Align.CENTER)
        
        apps = [
            ("Winlink", self.on_winlink_clicked),
            ("JS8", self.on_js8_clicked),
            ("VarAC", self.on_varac_clicked),
            ("QtTerm", self.on_bbs_clicked),
        ]
        
        for name, callback in apps:
            btn = Gtk.Button(label=name)
            btn.get_style_context().add_class("app-button")
            btn.connect("clicked", callback)
            button_box.pack_start(btn, False, False, 0)
        
        self.main_box.pack_start(button_box, False, False, 5)
        
        # Initial update
        self.update_info()
    
    def create_section_header(self, title, callback):
        box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        
        label = Gtk.Label(label=title)
        label.get_style_context().add_class("section-header")
        box.pack_start(label, False, False, 0)
        
        btn = Gtk.Button(label="⚙")
        btn.get_style_context().add_class("config-button")
        btn.set_tooltip_text("Configure")
        btn.connect("clicked", callback)
        box.pack_end(btn, False, False, 0)
        
        return box
    
    def create_info_row(self, label_text):
        label = Gtk.Label()
        label.set_halign(Gtk.Align.START)
        label.get_style_context().add_class("info-label")
        label.set_markup(f"<span>{label_text}: --</span>")
        return label
    
    def create_separator(self):
        sep = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        sep.get_style_context().add_class("separator")
        return sep
    
    def run_command(self, cmd):
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
            return result.stdout.strip()
        except Exception:
            return ""
    
    def update_info(self):
        # UTC Time
        utc = self.run_command("date -u '+%H:%M:%S'")
        self.utc_label.set_text(f"UTC: {utc}")
        
        # GPS Status
        gps = self.run_command("et-system-info et-gps 2>/dev/null")
        if gps and "not" not in gps.lower():
            self.gps_label.set_markup("<span foreground='#00CC00'>GPS: ✓</span>")
        else:
            self.gps_label.set_markup("<span foreground='#CC0000'>GPS: ✗</span>")
        
        # Radio
        radio = self.run_command("et-system-info active-radio 2>/dev/null") or "Not configured"
        self.radio_label.set_markup(f"<span foreground='#888888'>Radio: {radio}</span>")
        
        # CAT
        cat = self.run_command("et-system-info et-cat 2>/dev/null")
        if cat and "not" not in cat.lower():
            self.cat_label.set_markup(f"<span foreground='#888888'>CAT: </span><span foreground='#00CC00'>✓</span>")
        else:
            self.cat_label.set_markup(f"<span foreground='#888888'>CAT: </span><span foreground='#CC0000'>✗</span>")
        
        # Audio
        audio = self.run_command("et-system-info et-audio 2>/dev/null")
        if audio and "not" not in audio.lower():
            self.audio_label.set_markup(f"<span foreground='#888888'>Audio: </span><span foreground='#00CC00'>✓</span>")
        else:
            self.audio_label.set_markup(f"<span foreground='#888888'>Audio: </span><span foreground='#CC0000'>✗</span>")
        
        # Operator info
        try:
            config_path = os.path.expanduser("~/.config/emcomm-tools/user.json")
            if os.path.exists(config_path):
                with open(config_path) as f:
                    config = json.load(f)
                callsign = config.get("callsign", "N0CALL")
                grid = config.get("grid", "AA00aa")
            else:
                callsign = "N0CALL"
                grid = "AA00aa"
        except Exception:
            callsign = "N0CALL"
            grid = "AA00aa"
        
        self.callsign_label.set_text(callsign)
        self.grid_label.set_text(f"· {grid}")
        
        # Current mode
        mode = self.run_command("et-system-info et-mode 2>/dev/null") or "Not set"
        self.mode_label.set_text(mode)
        
        return True  # Continue timer
    
    def on_delete_event(self, widget, event):
        # Prevent closing - return True to block
        return True
    
    # === Click Handlers ===
    # ALL handlers use xfce4-terminal to ensure proper environment (Wine, etc.)
    def on_radio_clicked(self, widget):
        subprocess.Popen(["xfce4-terminal", "--command=/opt/emcomm-tools/bin/et-radio"])
    
    def on_user_clicked(self, widget):
        subprocess.Popen(["xfce4-terminal", "--command=/opt/emcomm-tools/bin/et-user"])
    
    def on_mode_clicked(self, widget):
        subprocess.Popen(["xfce4-terminal", "--command=/opt/emcomm-tools/bin/et-mode"])
    
    def on_winlink_clicked(self, widget):
        subprocess.Popen(["xfce4-terminal", "-e", "bash -l -c '/opt/emcomm-tools/bin/et-winlink-mode; exec bash'"])
    
    def on_js8_clicked(self, widget):
        """Launch JS8Call (et-js8call will also start JS8Spotter)"""
        subprocess.Popen(["/opt/emcomm-tools/bin/et-js8call", "start"])
    
    def on_varac_clicked(self, widget):
        subprocess.Popen(["/opt/emcomm-tools/bin/et-varac", "start"])
    
    def on_bbs_clicked(self, widget):
        subprocess.Popen(["xfce4-terminal", "-e", "bash -l -c '/opt/emcomm-tools/bin/et-qttermtcp-mode; exec bash'"])


def main():
    win = EmCommDashboard()
    # Don't connect destroy - we want it to stay running
    win.show_all()
    Gtk.main()


if __name__ == "__main__":
    main()
